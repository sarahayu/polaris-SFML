#include "MathUtils.h"
#include <iostream>

const float TAYLOR_PRECISION = 3;


const float mu::degToHr(const float &deg)
{
	return deg / 360.0f * 24.0f;
}

const float mu::timeToDec(const tm &ttime)
{
	return (float)ttime.tm_hour + ((float)ttime.tm_min / 60.0f) + ((float)ttime.tm_sec / 6000.0f);
}

const float mu::GST(const tm &ttime, const float &longtitude)
{
	tm ut = ttime;
	ut.tm_hour -= (int)(longtitude / 15.0f);
	if (ut.tm_hour < 0) ut.tm_hour += 24;

	float G = yearToG.at(ut.tm_year % 4), D = ut.tm_yday, T = timeToDec(ut);

	//std::cout << "\nGST = " << G << " + 0.0657098244 * " << D << " + 1.00273791 * " << T;

	float GST = G + 0.0657098244f * D + 1.00273791f * T;

	return std::fmod(GST, 24.0f);
}

const float mu::wrapLongtitude(const float &lon)
{
	float add = std::ceil(-(lon / 180.0f))*180.0f;
	return lon + add;
}

const sf::Vector3d mu::bv2rgb(double color)
{
	double t;  double r = 0.0; double g = 0.0; double b = 0.0; if (color<-0.4) color = -0.4; if (color> 2.0) color = 2.0;
	if ((color >= -0.40) && (color<0.00)) { t = (color + 0.40) / (0.00 + 0.40); r = 0.61 + (0.11*t) + (0.1*t*t); }
	else if ((color >= 0.00) && (color<0.40)) { t = (color - 0.00) / (0.40 - 0.00); r = 0.83 + (0.17*t); }
	else if ((color >= 0.40) && (color<2.10)) { t = (color - 0.40) / (2.10 - 0.40); r = 1.00; }
	if ((color >= -0.40) && (color<0.00)) { t = (color + 0.40) / (0.00 + 0.40); g = 0.70 + (0.07*t) + (0.1*t*t); }
	else if ((color >= 0.00) && (color<0.40)) { t = (color - 0.00) / (0.40 - 0.00); g = 0.87 + (0.11*t); }
	else if ((color >= 0.40) && (color<1.60)) { t = (color - 0.40) / (1.60 - 0.40); g = 0.98 - (0.16*t); }
	else if ((color >= 1.60) && (color<2.00)) { t = (color - 1.60) / (2.00 - 1.60); g = 0.82 - (0.5*t*t); }
	if ((color >= -0.40) && (color<0.40)) { t = (color + 0.40) / (0.40 + 0.40); b = 1.00; }
	else if ((color >= 0.40) && (color<1.50)) { t = (color - 0.40) / (1.50 - 0.40); b = 1.00 - (0.47*t) + (0.1*t*t); }
	else if ((color >= 1.50) && (color<1.94)) { t = (color - 1.50) / (1.94 - 1.50); b = 0.63 - (0.6*t*t); }

	return{ r * 255.0, g * 255.0, b * 255.0 };
}

const sf::Vector2f mu::toRad(const sf::Vector2f & deg)
{
	return{ toRad(deg.x), toRad(deg.y) };
}

const sf::Vector2f mu::toDeg(const sf::Vector2f & rad)
{
	return{ toDeg(rad.x), toDeg(rad.y) };
}

const sf::Vector3f mu::toRad(const sf::Vector3f & deg)
{
	return{ toRad(deg.x), toRad(deg.y), toRad(deg.z) };
}

const sf::Vector3f mu::toDeg(const sf::Vector3f & rad)
{
	return{ toDeg(rad.x), toDeg(rad.y), toDeg(rad.z) };
}


const float mu::toRad(const float & deg)
{
	return deg * PI / 180.0f;
}

const float mu::toDeg(const float & rad)
{
	return rad * 180.0f / PI;
}

const float mu::ratioToVega(const float &mag)		// 0-1
{
	return std::pow(10.0f, 0.4 * -mag);
}

const sf::Vector2f mu::celestialToHorizontal(const sf::Vector2f & celestialCoords, const sf::Vector2f & observerCoords, const float &localSidrealTime)
{
	const float az = celestialCoords.x,
		alt = celestialCoords.y,
		lat = observerCoords.x,
		lon = observerCoords.y;
	const float sinALT = std::sin(alt),
		sinLAT = std::sin(lat),
		cosLAT = std::cos(lat);
	const float dec = std::asin(sinALT*sinLAT + std::cos(alt)*cosLAT*std::cos(az));
	float primary_ha = std::acos((sinALT - (sinLAT*std::sin(dec))) / cosLAT*std::cos(dec));

	const float ha = std::sin(az) > 0 ? (360 - primary_ha) / 15.0f : primary_ha / 15.0f;
	float primary_ra = ha - localSidrealTime;
	const float ra = primary_ra < 0 ? primary_ra + 24 : primary_ra;

	return{ ra, dec };
}


sf::Vector2f mu::raToDeg(const sf::Vector2f &celestialCoords)
{
	float ra = celestialCoords.x;
	float dec = celestialCoords.y;

	ra = ra / 24.0f * 360.0f;
	ra = ra > 180.0f ? -(360.0f - ra) : ra;

	return{ ra, dec };
}

sf::Vector3f mu::celestialToCartesian(const sf::Vector2f & coords)
{
	return{ std::cos(toRad(coords.y)) * std::sin(toRad(coords.x)),
		std::sin(toRad(coords.y)),
		std::cos(toRad(coords.x)) * std::cos(toRad(coords.y)) };
}

sf::Vector3f mu::rotateAboutY(const sf::Vector3f & coords, const float & rotate)
{
	float z_ = coords.z, x_ = coords.x;

	return{ x_ * std::cos(rotate) - z_ * std::sin(rotate),
		coords.y,
		z_ * std::cos(rotate) + x_ * std::sin(rotate) };
}

sf::Vector3f mu::rotateAboutX(const sf::Vector3f & coords, const float & rotate)
{
	float y_ = coords.y, z_ = coords.z;

	return{ coords.x,
		y_ * std::cos(rotate) - z_ * std::sin(rotate),
		y_ * std::sin(rotate) + z_ * std::cos(rotate) };
}

sf::Vector3f mu::rotateAboutZ(const sf::Vector3f & coords, const float & rotate)
{
	float x_ = coords.x, y_ = coords.y;

	return{ x_ * std::cos(rotate) - y_ * std::sin(rotate),
		x_ * std::sin(rotate) + y_ * std::cos(rotate),
		coords.z };
}

sf::Vector3f mu::rotate(const sf::Vector3f & coords, const sf::Vector3f &rotation)
{
	return rotateAboutX(rotateAboutY(rotateAboutZ(coords, rotation.z), rotation.y), rotation.x);
}

sf::Vector2f mu::cartesianToSG(const sf::Vector3f & coords)
{
	return{ coords.x / (1.0f + coords.z) , coords.y / (1.0f + coords.z) };
}

const sf::Vector2f mu::SGToScreen(const sf::Vector2f & SGCoord, const sf::Vector2f &screenSize)
{
	return{ SGCoord.x * (screenSize.x / 2.0f),
		-SGCoord.y * (screenSize.y / 2.0f) };
}

const sf::Vector2f mu::cartesianToScreen(const sf::Vector3f & cartesianCoords, const sf::Vector3f & rotation, const sf::Vector2f &screenSize)
{
	return SGToScreen(
		cartesianToSG(
			rotate(cartesianCoords, rotation)), screenSize);
}

// courtesy of http://129.79.46.40/~foxd/cdrom/musings/formulas/formulas.htm //

const tm mu::toGreenwichMeanTime(const tm & localTime, const float & longtitude)
{
	tm gmt(localTime);
	gmt.tm_hour -= std::round(longtitude / 360.0f * 24.0f);

	mktime(&gmt);	// account for out of range hour values

	return gmt;
}

const float mu::toDecimalHours(const tm & ttime)
{
	return ttime.tm_hour + ttime.tm_min / 60.0f + ttime.tm_sec / 3600.0f;
}

const float mu::getJulianDate(const tm & gmt)
{

	int y = gmt.tm_year + 1900, m = gmt.tm_mon + 1;
	if (m == 1 || m == 2)
	{
		y -= 1;
		m += 12;
	}

	int A = (int)(y / 100.0f),
		B = 2 - A + (int)(A / 4),
		C = y < 0 ? (int)((365.25f * y) - 0.75f) : (int)(365.25f * y),
		D = gmt.tm_mday,
		E = (int)(30.6001f * (m + 1));

	return B + C + D + E + 1720994.5f;
}

const float mu::getGreenwichSidrealTime(const tm & gmt)
{

	float JD = getJulianDate(gmt);
	float UT = toDecimalHours(gmt);
	float T = (JD - 2451545.0f) / 36525.0f;
	float T0 = 6.697374558f + 2400.051336f*T + 0.000025862f*T * T + UT*1.0027379093f;

	while (T0 < 0.0f) T0 += 24.0f;
	while (T0 > 24.0f) T0 -= 24.0f;

	return T0;
}

const float mu::getLocalSidrealTime(const tm & gmt, const float & longtitude)
{

	float lst = getGreenwichSidrealTime(gmt) + (longtitude / 15.0f);

	while (lst < 0.0f) lst += 24.0f;
	while (lst > 24.0f) lst -= 24.0f;

	return lst;
}

const float mu::ccos(const float & angle)
{
	float wrapped = std::abs(angle - PI * 2 * std::floor((angle + PI) / (2 * PI)));

	if (wrapped > PI / 2) return -taylorSin(wrapped - PI / 2);
	return taylorCos(wrapped);
	
}

const float mu::ssin(const float & angle)
{
	return std::cos(PI / 2 - angle);
}

const float mu::taylorCos(const float & angle)
{
	float result = 1;
	float a = 1, b = 1, c = 1;
	for (int i = 1; i < TAYLOR_PRECISION; i++)
	{
		a *= -1, b *= angle * angle, c *= 2 * i * (2 * i - 1);
		result += a * b / c;
	}
	return result;
}

const float mu::taylorSin(const float & angle)
{
	float result = angle;
	float a = 1, b = angle, c = 1;
	for (int i = 1; i < TAYLOR_PRECISION; i++)
	{
		a *= -1, b *= angle * angle, c *= 2 * i * (2 * i + 1);
		result += a * b / c;
	}
	return result;
}