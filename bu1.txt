#include "Menu.h"
#include "../RenderSettings.h"
#include "../utils/MathUtils.h"
#include "../utils/StringUtils.h"
#include <iostream>
#include <ctime>
#include <sstream>

const float MENU_WIDTH = 350.0f;

Menu::Menu(sf::RenderWindow & window, RenderSettings & renderSettings)
	: r_window(window), r_renderSettings(renderSettings), p_activeTextBox(nullptr)
{
	sf::Vector2f menuLoc(r_window.getSize().x - MENU_WIDTH, 0.0f);

	m_menuRect.setSize({ MENU_WIDTH, (float)r_window.getSize().y });
	m_menuRect.setPosition(menuLoc);
	m_menuRect.setFillColor(sf::Color(8, 8, 8, 173));

	m_fgothic.loadFromFile("resources/franklin-gothic.ttf");


	// -------------------- instantiate controls/directions ----------------- //

	std::vector<std::string> controlStrings
	{
		"Press [F1] to toggle this menu",
		"Press [F2] to toggle star names",
		"Press [F3] to toggle gridlines",
		"Press [Esc] to unbind mouse",
		"Scroll or use up/down arrow keys",
		"  to simulate dimmer/brighter ",
		"  light conditions",
		"Press [Ctrl] and scroll or use",
		"  up/down arrow keys to zoom in",
		"  or out"
	};

	sf::Vector2f lastLocation = instantiateSection<std::string>({ 30.0f, 50.0f }, { 0.0f, 40.0f }, controlStrings,
		[&](const std::string &s, const sf::Vector2f &loc) { createItem(s, MenuText(sf::Text(s, m_fgothic, 16U), loc, menuLoc, sf::Color(184, 184, 184))); });

	lastLocation.y += 40.0f;

	/*

	const sf::Vector2f controlsStart(30.0f, 50.0f);
	const sf::Vector2f controlsMargin(0.0f, 40.0f);
	sf::Vector2f controlLoc = controlsStart;

	for (const std::string &string : controlStrings)
	{
		// use string as name TODO change?
		createItem(string, MenuText(sf::Text(string, m_fgothic, 16U), controlLoc, menuLoc, sf::Color(184, 184, 184)));
		//m_texts.push_back(MenuText(sf::Text(string, m_fgothic, 16U), controlLoc, menuLoc, sf::Color(184,184,184)));
		controlLoc += controlsMargin;
	}*/

	// -------------------- instantiate separators ----------------- //

	sf::Vector2f m_horizLoc = sf::Vector2f(controlLoc += sf::Vector2f(0.0f, 30.0f));

	createItem("horizontalLine", HorizontalLine(m_horizLoc, MENU_WIDTH - 60.0f, menuLoc, sf::Color(59, 59, 59)));

	//m_separators.push_back(HorizontalLine(m_horizLoc, MENU_WIDTH - 60.0f, menuLoc, sf::Color(59, 59, 59)));

	// -------------------- instantiate settings area ----------------- //

	const sf::Vector2f settingsStart(controlLoc + sf::Vector2f(5.0f, 50.0f));
	const sf::Vector2f settingsMargin(0.0f, 50.0f);
	sf::Vector2f settingsLoc = settingsStart;

	std::vector<std::string> settingsStrings
	{
		"Date",
		"Time"
	};

	for (const std::string &string : settingsStrings)
	{
		// use string as label TODO change?
		createItem(string, MenuText(sf::Text(string, m_fgothic, 15U), settingsLoc, menuLoc, sf::Color(184, 184, 184)));
		//m_texts.push_back(MenuText(sf::Text(string, m_fgothic, 15U), settingsLoc, menuLoc, sf::Color(184, 184, 184)));
		settingsLoc += settingsMargin;
	}

	time_t now = time(0);
	tm *ltm = localtime(&now);

	struct StringPair { std::string first, second; };

	std::vector<StringPair> settingsDefaults
	{
		{ "dateBox", std::to_string(1 + ltm->tm_mon) + "/" + std::to_string(ltm->tm_mday) + "/" + std::to_string(1900 + ltm->tm_year) },
		{ "timeBox", std::to_string(ltm->tm_hour) + ":" + (ltm->tm_min < 10 ? "0" + std::to_string(ltm->tm_min) : std::to_string(ltm->tm_min)) }
	};

	const sf::Vector2f defaultsMargin(0.0f, 50.0f);
	sf::Vector2f defaultsLoc = settingsStart + sf::Vector2f(140.0f, -10.0f);

	for (const StringPair &defPair : settingsDefaults)
	{
		createTextBox(defPair.first, MenuTextBox(defPair.first, sf::Text(defPair.second, m_fgothic, 15U), defaultsLoc, sf::Vector2f(10.0f, 10.0f), menuLoc, sf::Color(124, 124, 124), sf::Color(19, 19, 19)));
		//m_textBoxes.insert({defPair.first, MenuTextBox(defPair.first, sf::Text(defPair.second, m_fgothic, 15U), defaultsLoc, sf::Vector2f(10.0f, 10.0f), menuLoc, sf::Color(124, 124, 124), sf::Color(19, 19, 19)) });
		defaultsLoc += defaultsMargin;
	}

	const sf::Vector2f buttonSize(150.0f, 33.0f);
	settingsLoc.x = (MENU_WIDTH - buttonSize.x) / 2.0f;

	createItem("button1", Button(sf::Text("Reset Time", m_fgothic, 15U), settingsLoc, buttonSize, sf::Color(124, 124, 124), "resources/time.png", menuLoc));

	settingsLoc.x = settingsStart.x;
	settingsLoc.y += 88.0f;

	const sf::Vector2f settingsStart2 = settingsLoc;
	const sf::Vector2f settingsMargin2(0.0f, 50.0f);
	sf::Vector2f settingsLoc2 = settingsStart2;

	std::vector<std::string> settingsStrings2
	{
		"Latitude",
		"Longtitude"
	};

	for (const std::string &string : settingsStrings2)
	{
		// use string as label TODO change?
		createItem(string, MenuText(sf::Text(string, m_fgothic, 15U), settingsLoc2, menuLoc, sf::Color(184, 184, 184)));
		//m_texts.push_back(MenuText(sf::Text(string, m_fgothic, 15U), settingsLoc, menuLoc, sf::Color(184, 184, 184)));
		settingsLoc2 += settingsMargin2;
	}

	std::vector<StringPair> settingsDefaults2
	{
		{ "latBox", "0" },
		{ "lonBox", "0" }
	};

	const sf::Vector2f defaultsMargin2(0.0f, 50.0f);
	sf::Vector2f defaultsLoc2 = settingsStart2 + sf::Vector2f(140.0f, -10.0f);

	for (const StringPair &defPair : settingsDefaults2)
	{
		createTextBox(defPair.first, MenuTextBox(defPair.first, sf::Text(defPair.second, m_fgothic, 15U), defaultsLoc2, sf::Vector2f(10.0f, 10.0f), menuLoc, sf::Color(124, 124, 124), sf::Color(19, 19, 19)));
		//m_textBoxes.insert({defPair.first, MenuTextBox(defPair.first, sf::Text(defPair.second, m_fgothic, 15U), defaultsLoc, sf::Vector2f(10.0f, 10.0f), menuLoc, sf::Color(124, 124, 124), sf::Color(19, 19, 19)) });
		defaultsLoc2 += defaultsMargin2;
	}

	// error message //
	p_errorMessage =  createItem("errorMessage", MenuText(sf::Text("", m_fgothic, 13U), { 30.0f, defaultsLoc2.y + 10.0f }, menuLoc, sf::Color(237, 35, 52)));

	// -------------------- finally parse settings so Renderer can factor in time ----------------- //

	parseSettings();
}

void Menu::draw()
{
	sf::Vector2f windowSize(r_window.getSize());
	r_window.setView(sf::View(windowSize / 2.0f, windowSize));

	sf::Vector2f menuLoc(r_window.getSize().x - MENU_WIDTH, 0.0f);
	m_menuRect.setPosition(menuLoc);
	m_menuRect.setSize({ MENU_WIDTH, (float)r_window.getSize().y });
	r_window.draw(m_menuRect);

	for (auto &itemPair : m_menuItems)
	{
		const MenuItem::Ptr &item = itemPair.second;
		item->setParentLocation(menuLoc);
		item->draw(r_window);
	}
	/*

	for (HorizontalLine &line : m_separators)
	{
		line.setParentLocation(menuLoc);
		line.draw(r_window);
	}

	for (MenuText &text : m_texts)
	{
		text.setParentLocation(menuLoc);
		text.draw(r_window);
	}

	for (auto &pair : m_textBoxes)
	{
		MenuTextBox &tBox = pair.second;
		tBox.setParentLocation(menuLoc);
		tBox.draw(r_window);
	}*/
}

bool Menu::receiveInput(const sf::Event & evnt)
{
	if (!r_renderSettings.windowFocused) return false;

	switch (evnt.type)
	{
		case sf::Event::MouseButtonPressed:
		{
			sf::Vector2i mousePos(evnt.mouseButton.x, evnt.mouseButton.y);

			for (MenuTextBox::Ptr &tBox : m_textBoxes)
			{
				if (tBox->isWithinBounds(sf::Vector2f(mousePos)))
				{
					std::cout << "\nPressed! " << tBox->getName();
					if (p_activeTextBox != nullptr) p_activeTextBox->active = false;

					tBox->active = true;
					p_activeTextBox = tBox;
					return true;
				}
			}

			// did not click any text box //

			if (p_activeTextBox != nullptr)	
			{
				std::cout << "\nTextbox : " << p_activeTextBox->getName();
				parseSettings();
				p_activeTextBox->active = false;
				p_activeTextBox = nullptr;
				return true;
			}
		}
		break;
		case sf::Event::KeyPressed:
		{
			if (p_activeTextBox != nullptr)
			{
				if (evnt.key.code == sf::Keyboard::BackSpace)
				{
					p_activeTextBox->backspace();
					return true;
				}
			
				if (evnt.key.code == sf::Keyboard::Return)
				{
					std::cout << "\nTextbox : " << p_activeTextBox->getName();
					std::cout << "\nValue : " << p_activeTextBox->getValue();
					parseSettings();
					p_activeTextBox->active = false;
					p_activeTextBox = nullptr;
					return true;
				}
			}
		}
		break;
		case sf::Event::TextEntered:
		{
			if (p_activeTextBox != nullptr)
			{
				if (su::isChar(evnt.text.unicode))
				{
					std::string c;
					c = (char)evnt.text.unicode;
					p_activeTextBox->addText(c);

					return true;
				}
			}
		}
		break;
	}

	return false;
}

const sf::FloatRect Menu::getBounds() const
{
	return m_menuRect.getGlobalBounds();
}

MenuTextBox::Ptr Menu::createTextBox(const std::string & key, const MenuTextBox & textBox)
{
	MenuTextBox::Ptr pTextBox = createItem(key, textBox);
	m_textBoxes.push_back(pTextBox);
	return pTextBox;
}

MenuTextBox::Ptr Menu::getTextBox(const std::string & key)
{
	return getItem<MenuTextBox>(key);
}

void Menu::parseSettings()
{
	p_errorMessage->setString(calculateGST());
}

const std::string Menu::calculateGST()
{
	std::vector<std::string> dateStrings = su::split(getTextBox("dateBox")->getValue(), '/');

	if (dateStrings.size() != 3) return "Invalid date format";

	for (const std::string &s : dateStrings) if (!su::isDigit(s)) return "Invalid date value '" + s + "'";
	
	float mo = su::strToF(dateStrings[0]),
		d = su::strToF(dateStrings[1]), 
		yr = su::strToF(dateStrings[2]);

	//std::cout << "\nDate : " << mo << "/" << d << "/" << yr;

	std::vector<std::string> hourStrings = su::split(getTextBox("timeBox")->getValue(), ':');

	if (hourStrings.size() != 2) return "Invalid time format";

	for (const std::string &s : hourStrings) if (!su::isDigit(s)) return "Invalid time value '" + s + "'";

	int hr = su::strToD(hourStrings[0]), min = su::strToD(hourStrings[1]);

	//std::cout << "\nTime : " << hr << ":" << min;
	
	std::string strLat = getTextBox("latBox")->getValue(), strLon = getTextBox("lonBox")->getValue();

	if (!su::isFloat(strLat)) return "Invalid latitude value '" + strLat + "'";
	if (!su::isFloat(strLon)) return "Invalid longtitude value '" + strLon + "'";

	float lat = su::strToF(getTextBox("latBox")->getValue()), lon = su::strToF(getTextBox("lonBox")->getValue());
	
	// reset values in case there were characters in strings //
	getTextBox("dateBox")->setValue(std::to_string((int)mo) + "/" + std::to_string((int)d) + "/" + std::to_string((int)yr));
	getTextBox("timeBox")->setValue(std::to_string(hr) + ":" + (min < 10 ? "0" + std::to_string(min) : std::to_string(min)));
	getTextBox("latBox")->setValue(std::to_string(lat + 0.0f));
	getTextBox("lonBox")->setValue(std::to_string(lon + 0.0f));

	//std::cout << "\nLocation : " << lat << "," << lon;

	tm set = { 0,min,hr,d,mo - 1,yr - 1900 };
	mktime(&set);

	float gst = mu::GST(set, lon);

	std::cout << "\nGST : " << su::toString(gst);

	float diffGST = gst - mu::HYG_EPOCH_GST;

	if (diffGST < 0.0f) diffGST += 24.0f;

	float lst = diffGST + (lon / 15.0f);
	if (lst < 0.0f) lst += 24.0f;

	std::cout << "\nHonolulu LST minus 2000 GST: " << su::toString(std::fmod(lst, 24.0f));

	r_renderSettings.skyOffset.x = -(lst / 24.0f * 2.0f * mu::PI);
	r_renderSettings.skyOffset.y = -((90.0f - lat) / 360.0f * 2.0f * mu::PI);

	return "";		// no errors in calculating gst, set error message to none
}
