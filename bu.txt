#include "Menu.h"
#include "../RenderSettings.h"
#include "../utils/MathUtils.h"
#include "../utils/StringUtils.h"
#include <iostream>
#include <ctime>
#include <sstream>

Menu::Menu(sf::RenderWindow & window, RenderSettings & renderSettings)
	: r_window(window), r_renderSettings(renderSettings), p_activeTextBox(nullptr)
{
	sf::Vector2f menuLoc(r_window.getSize().x - menuWidth, 0.0f);

	m_menuRect.setSize({ menuWidth, (float)r_window.getSize().y });
	m_menuRect.setPosition(menuLoc);
	m_menuRect.setFillColor(sf::Color(8, 8, 8, 173));

	m_fgothic.loadFromFile("resources/franklin-gothic.ttf");

	// -------------------- instantiate controls/directions ----------------- //

	std::vector<std::string> controlStrings
	{
		"Press [F1] to toggle this menu",
		"Press [F2] to toggle star names",
		"Press [F3] to toggle gridlines",
		"Press [Esc] to unbind mouse",
		"Scroll or use up/down arrow keys",
		"  to simulate dimmer/brighter ",
		"  light conditions",
		"Press [Ctrl] and scroll or use",
		"  up/down arrow keys to zoom in",
		"  or out"
	};

	const sf::Vector2f controlsStart(30.0f, 50.0f);
	const sf::Vector2f controlsMargin(0.0f, 40.0f);
	sf::Vector2f controlLoc = controlsStart;

	for (const std::string &string : controlStrings)
	{
		m_texts.push_back(MenuText(sf::Text(string, m_fgothic, 16U), controlLoc, menuLoc, sf::Color(184,184,184)));
		controlLoc += controlsMargin;
	}

	// -------------------- instantiate separators ----------------- //

	sf::Vector2f m_horizLoc = sf::Vector2f(controlLoc += sf::Vector2f(0.0f, 30.0f));

	m_separators.push_back(HorizontalLine(m_horizLoc, menuWidth - 60.0f, menuLoc, sf::Color(59, 59, 59)));

	// -------------------- instantiate settings area ----------------- //

	const sf::Vector2f settingsStart(controlLoc + sf::Vector2f(5.0f, 50.0f));
	const sf::Vector2f settingsMargin(0.0f, 50.0f);
	sf::Vector2f settingsLoc = settingsStart;

	std::vector<std::string> settingsStrings
	{
		"Date",
		"Time",
		"Latitude",
		"Longtitude"
	};

	for (const std::string &string : settingsStrings)
	{
		m_texts.push_back(MenuText(sf::Text(string, m_fgothic, 15U), settingsLoc, menuLoc, sf::Color(184, 184, 184)));
		settingsLoc += settingsMargin;
	}

	time_t now = time(0);
	tm *ltm = localtime(&now);

	struct StringPair { std::string first, second; };

	std::vector<StringPair> settingsDefaults
	{
		{ "dateBox", std::to_string(1 + ltm->tm_mon) + "/" + std::to_string(ltm->tm_mday) + "/" + std::to_string(1900 + ltm->tm_year) },
		{ "timeBox", std::to_string(ltm->tm_hour) + ":" + (ltm->tm_min < 10 ? "0" + std::to_string(ltm->tm_min) : std::to_string(ltm->tm_min)) },
		{ "latBox", "0" },
		{ "lonBox", "0" }
	};

	const sf::Vector2f defaultsMargin(0.0f, 50.0f);
	sf::Vector2f defaultsLoc = settingsStart + sf::Vector2f(140.0f, -10.0f);

	for (const StringPair &defPair : settingsDefaults)
	{
		std::cout << "\n - " << defPair.first;
		m_textBoxes.insert({defPair.first, MenuTextBox(defPair.first, sf::Text(defPair.second, m_fgothic, 15U), defaultsLoc, sf::Vector2f(10.0f, 10.0f), menuLoc, sf::Color(124, 124, 124), sf::Color(19, 19, 19)) });
		defaultsLoc += defaultsMargin;
	}

	// error message //
	m_texts.push_back(MenuText(sf::Text("", m_fgothic, 13U), { 30.0f, defaultsLoc.y + 10.0f }, menuLoc, sf::Color(237, 35, 52)));
	p_errorMessage = &m_texts.back();

	// -------------------- finally parse settings so Renderer can factor in time ----------------- //

	parseSettings();
}

void Menu::draw()
{
	sf::Vector2f windowSize(r_window.getSize());
	r_window.setView(sf::View(windowSize / 2.0f, windowSize));

	sf::Vector2f menuLoc(r_window.getSize().x - menuWidth, 0.0f);
	m_menuRect.setPosition(menuLoc);
	m_menuRect.setSize({ menuWidth, (float)r_window.getSize().y });
	r_window.draw(m_menuRect);

	for (HorizontalLine &line : m_separators)
	{
		line.setParentLocation(menuLoc);
		line.draw(r_window);
	}

	for (MenuText &text : m_texts)
	{
		text.setParentLocation(menuLoc);
		text.draw(r_window);
	}

	for (auto &pair : m_textBoxes)
	{
		MenuTextBox &tBox = pair.second;
		tBox.setParentLocation(menuLoc);
		tBox.draw(r_window);
	}
}

bool Menu::receiveInput(const sf::Event & evnt)
{
	if (!r_renderSettings.windowFocused) return false;

	switch (evnt.type)
	{
		case sf::Event::MouseButtonPressed:
		{
			sf::Vector2i mousePos(evnt.mouseButton.x, evnt.mouseButton.y);

			for (auto &pair : m_textBoxes)
			{
				MenuTextBox &tBox = pair.second;

				if (tBox.isWithinBounds(sf::Vector2f(mousePos)))
				{

					std::cout << "\nPressed! " << tBox.getName();
					if (p_activeTextBox != nullptr) p_activeTextBox->active = false;

					tBox.active = true;
					p_activeTextBox = &pair.second;
					return true;
				}
			}

			// did not click any text box //

			if (p_activeTextBox != nullptr)	
			{
				std::cout << "\nTextbox : " << p_activeTextBox->getName();
				parseSettings();
				p_activeTextBox->active = false;
				p_activeTextBox = nullptr;
				return true;
			}
		}
		break;
		case sf::Event::KeyPressed:
		{
			if (p_activeTextBox != nullptr)
			{
				if (evnt.key.code == sf::Keyboard::BackSpace)
				{
					p_activeTextBox->backspace();
					return true;
				}
			
				if (evnt.key.code == sf::Keyboard::Return)
				{
					std::cout << "\nTextbox : " << p_activeTextBox->getName();
					std::cout << "\nValue : " << p_activeTextBox->getValue();
					parseSettings();
					p_activeTextBox->active = false;
					p_activeTextBox = nullptr;
					return true;
				}
			}
		}
		break;
		case sf::Event::TextEntered:
		{
			if (p_activeTextBox != nullptr)
			{
				if (su::isChar(evnt.text.unicode))
				{
					std::string c;
					c = (char)evnt.text.unicode;
					p_activeTextBox->addText(c);

					return true;
				}
			}
		}
		break;
	}

	return false;
}

const sf::FloatRect Menu::getBounds() const
{
	return m_menuRect.getGlobalBounds();
}

void Menu::parseSettings()
{
	p_errorMessage->setString(calculateGST());
}

const std::string Menu::calculateGST()
{
	std::vector<std::string> dateStrings = su::split(m_textBoxes["dateBox"].getValue(), '/');

	if (dateStrings.size() != 3) return "Invalid date format";

	for (const std::string &s : dateStrings) if (!su::isDigit(s)) return "Invalid date value '" + s + "'";
	
	float mo = su::strToF(dateStrings[0]),
		d = su::strToF(dateStrings[1]), 
		yr = su::strToF(dateStrings[2]);

	//std::cout << "\nDate : " << mo << "/" << d << "/" << yr;

	std::vector<std::string> hourStrings = su::split(m_textBoxes["timeBox"].getValue(), ':');

	if (hourStrings.size() != 2) return "Invalid time format";

	for (const std::string &s : hourStrings) if (!su::isDigit(s)) return "Invalid time value '" + s + "'";

	int hr = su::strToD(hourStrings[0]), min = su::strToD(hourStrings[1]);

	//std::cout << "\nTime : " << hr << ":" << min;
	
	std::string strLat = m_textBoxes["latBox"].getValue(), strLon = m_textBoxes["lonBox"].getValue();

	if (!su::isFloat(strLat)) return "Invalid latitude value '" + strLat + "'";
	if (!su::isFloat(strLon)) return "Invalid longtitude value '" + strLon + "'";

	float lat = su::strToF(m_textBoxes["latBox"].getValue()), lon = su::strToF(m_textBoxes["lonBox"].getValue());
	
	// reset values in case there were characters in strings //
	m_textBoxes["dateBox"].setValue(std::to_string((int)mo) + "/" + std::to_string((int)d) + "/" + std::to_string((int)yr));
	m_textBoxes["timeBox"].setValue(std::to_string(hr) + ":" + (min < 10 ? "0" + std::to_string(min) : std::to_string(min)));
	m_textBoxes["latBox"].setValue(std::to_string(lat + 0.0f));
	m_textBoxes["lonBox"].setValue(std::to_string(lon + 0.0f));

	//std::cout << "\nLocation : " << lat << "," << lon;

	tm set = { 0,min,hr,d,mo - 1,yr - 1900 };
	mktime(&set);

	float gst = mu::GST(set, lon);

	std::cout << "\nGST : " << su::toString(gst);

	float diffGST = gst - mu::HYG_EPOCH_GST;

	if (diffGST < 0.0f) diffGST += 24.0f;

	float lst = diffGST + (lon / 15.0f);
	if (lst < 0.0f) lst += 24.0f;

	std::cout << "\nHonolulu LST minus 2000 GST: " << su::toString(std::fmod(lst, 24.0f));

	r_renderSettings.skyOffset.x = -(lst / 24.0f * 2.0f * mu::PI);
	r_renderSettings.skyOffset.y = -((90.0f - lat) / 360.0f * 2.0f * mu::PI);

	return "";		// no errors in calculating gst, set error message to none
}
